模拟器关于数据冒险的解决

解决数据冒险的两种手段：加载互锁，数据前递

数据前递的实现方法是在流水线状态中ID_input中加入了三个前递数据槽。其中两个接受EX流水级转发的数据，一个接受MEM流水级转发的数据。为EX设立两个数据槽的原因是，Unicore32指令集中的访存指令可以进行对基址寄存器的回写。因此相邻的两条指令中可能产生多达4次的回写。同时Unicore32指令最多可以有3个源寄存器。基于以上事实可知，仅仅两个数据槽不能满足所有的前递要求。因此需要为EX阶段增加一个数据槽。MEM阶段因为距离WB阶段只有1个周期，因此只需要有一个数据槽即可。

加载互锁的实现比较简单，只需在ID阶段判断是否前一个流水级是否为load指令，该load指令与当前ID阶段的指令是否有数据相关即可。发生相关的条件是要读取的寄存器号与需要回写的寄存器号相同。由于流水线和模拟器流程执行顺序的关系，ID阶段要判断的回写信息存储在流水线状态中的mem_in一级。当然，如果ID之后的流水级中插入了气泡，那么判断无需暂停流水线。

因此对于数据冒险问题的解决可以概括如下：
前递方面：
前递的信息来自与回写信号，即wb_dest_sel。为EX设立的两个数据槽形成一个队列，第一个数据槽永远保存最新一次的前递信息。
读寄存器堆方面：
1.首先判断是否需要进行加载互锁，如果是，暂停流水线，否则进行2。
2.先扫描前递槽，需要注意的是EX数据前递槽的第二个槽要最后扫描，如果命中则取数据。未命中，则直接从寄存器堆取数据。
