模拟器流水线设计

整体结构
minisim模拟的是经典的五级流水线，模拟粒度介于指令级和信号级之间。流水线的五个流水级为取值（IF），译码（ID），执行（EX），访存（MEM），回写（WB）。真实的处理器在工作时，流水线的各个流水级是并行运作的。但是软件要做到真实的并发比较困难。在我们的设计中，对各个流水级的模拟是按照从回写到取值的顺序依次执行的。模拟器最上层的执行过程可表示如下：
while(1)
{
    WB;
    MEM;
    EX;
    ID;
	if(stalling)
    {
        gen-bubble;
        continue;
    }
    IF;
    if(sim-end)
        break;
}
如上所示，ID和IF在执行后会返回一些关于流水线控制的信息，根据这些信息流水线会暂停，或直接停止模拟。暂停的原因是在ID阶段发现了数据冒险，并判断出需要进行加载互锁。关于数据冒险的处理会在后面详细说明。模拟过程停止的时机则在IF阶段决定。

IF
IF阶段完成的工作是取值，判断关键入口并进行处理，或者判断模拟是否已经结束。
 关键入口
最初已经提到，我们的模拟器无法处理与处理器特权态有关的指令，加之编译器方面的限制，只能支持一种与系统调用有关的行为，即输出一个整数。在模拟器执行指令前的ELF文件载入工作中已经获得了封装输出子例程的函数入口。IF阶段要做的就是判断当前的PC是否为这个关键入口，如果是，则IF向ID送出一条伪指令，编码为0xffffffff。这条指令在ID阶段会被进行特殊处理。
 模拟结束的时机
在执行指令之前，会对流水线进行初始化。其中比较重要的是设置OC为main函数的入口，同时将lr寄存器的值设置为0。这样一旦在IF阶段发现PC为全0，就可以认为模拟即将结束了。此时IF阶段会在产生4个汽泡后（带其他流水级中的指令执行完毕），产生结束模拟的信息。

ID
ID阶段是五个流水级中最复杂的阶段，需要完成的工作较多。主要有以下几项
  指令译码
对指令进行译码，根据指令信息产生相关的控制信号（在程序中就是为与控制有关的变量赋相应的值）。
  产生操作数
  EX阶段所需要的两个操作数也在ID阶段产生，所以需要完成读寄存器堆、对寄存器中的值进行移位等工作。这之中伴随着数据冒险的检测和解决。
     数据冒险的解决
解决数据冒险的两种手段：加载互锁，数据前递

数据前递的实现方法是在流水线状态信息（数据结构为PipeState）的ID_input域中加入了三个前递数据槽。其中两个接受EX流水级前递的数据，一个接受MEM流水级前递的数据。为EX设立两个数据槽的原因是，Unicore32指令集中的访存指令可以进行对基址寄存器的回写。因此相邻的两条指令中可能产生多达4次的回写。同时Unicore32指令最多可以有3个源寄存器。基于以上事实可知，仅仅两个数据槽不能满足所有的前递要求。因此需要为EX阶段增加一个数据槽。MEM阶段因为距离WB阶段只有1个周期，因此只需要有一个数据槽即可。

加载互锁的实现比较简单，只需在ID阶段判断是否前一个流水级是否为load指令，该load指令与当前ID阶段的指令是否有数据相关即可。发生相关的条件是要读取的寄存器号与需要回写的寄存器号相同。由于流水线和模拟器流程执行顺序的关系，ID阶段要判断的回写信息存储在流水线状态中的mem_in一级。当然，如果ID之后的流水级中插入了气泡，那么判断无需暂停流水线。

因此对于数据冒险问题的解决可以概括如下：
前递方面：
前递的信息来自与回写信号，即wb_dest_sel。为EX设立的两个数据槽形成一个队列，第一个数据槽永远保存最新一次的前递信息。
读寄存器堆方面：
1.首先判断是否需要进行加载互锁，如果是，暂停流水线，否则进行2。
2.先扫描前递槽，需要注意的是EX数据前递槽的第二个槽要最后扫描，如果命中则取数据。未命中，则直接从寄存器堆取数据。

     移位操作
  EX阶段需要的第二操作数一般并不是某个寄存器中的数据本身，而是需要对其进行某种移位操作。在这过程中还需要根据移位情况对CMSR的C位进行设置。
