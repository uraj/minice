三地值代码生成
	1、表达式以下部分利用语法数处理
	2、表达式以上部分在文法中通过拉链回填处理并按序组织起表达式翻译所生成的三地值代码。
	其中拉链回填的结构体：
	struct taexpr_list_header
	{
		struct triargexpr_list *head;
		struct triargexpr_list *tail;
		struct patch_list * nextlist;
	};
	对于每一个规约上来的statement都会产生一个此结构，用来记录该statement所对应的三地值代码以及该statement的nextilist。
	在
	struct taexpr_list_header * expr_list_gen(/**/);
	struct taexpr_list_header * value_list_append(/**/);
	struct taexpr_list_header * if_else_list_merge(/**/);
	struct taexpr_list_header * if_list_merge(/**/);
	struct taexpr_list_header * while_list_merge(/**/);
	struct taexpr_list_header * for_list_merge(/**/);
	struct taexpr_list_header * return_list_append(/**/);
	struct taexpr_list_header * stmt_list_merge(/**/);
	以上函数分别用来处理单个表达式、if-else语句、单if语句、while循环、for循环、return语句，以及各个statement之间的链接。

	3、中间代码组织形式
	struct triargtable
	{
		char * funcname;
		struct triargexpr_list *head, *tail;
		struct triargexpr * table;
		struct triargexpr_list ** index_to_list;
		int expr_num;
		int var_id_num;
		int table_bound;
	};
	此结构体用来保存每一个函数的中间代码，其中table数组中的三地址代码是以中间代码生成的顺序而保存的，因为在代码优化阶段可能要对中间代码的顺序进行大量的调度、删除或添加，所以我们用这个顺序的数组来保存三地址码实体，而用链表组织三地值代码的顺序，以下便是组织三地值代码顺序的链表结构体：
	struct triargexpr_list
	{
		int entity_index;
		struct var_list * pointer_entity;  
		struct triargexpr_list* prev;
		struct triargexpr_list* next;
	};
	其中entity_index用来指示对应的三地址代码在顺序表中对应的标号，而pointer_entity则是指针分析时返回的结果，用来记录每一个对指针所指内存进行操作的三地值代码中该指针可能对应的所有实体。
	因为需要建立链表节点和三地值代码实体的标号之间的双射，所以该结构体中存储了一个index_to_list数组，用来记录每一个三地值代码实体所对应的链表节点。
	



基本块划分及流图化简
	编译器在基本块划分过程中进行了两遍扫描，在这两遍扫描中不仅完成了基本块的划分，还充分利用两遍扫描尽可能地进行了数据处理和代码优化。同时在这一过程中，不仅要进行基本块划分，还要为最后基本块向代码的还原做好准备。下面便对两遍扫描以及之后的流图扫描所实现的功能进行简单的介绍。

	一、代码的第一遍顺序扫描
		1、标记函数中所有可能的入口语句，为第二编扫描中的基本块划分做准备
		2、优化绝对发生的条件跳转为无条件跳转，为第二遍扫描中不可达代码和无用跳转的删除做准备。
			在第一遍扫描中会将所有条件恒为真的TrueJump和条件恒为假的FalseJump改为UncondJump，而将所有条件恒为假的TrueJump和条件恒为真的FalseJump改为Nullop，这样可以防止这样的代码打断基本块，而Nullop在最终生成目标代码时是不产生指令的。
			例如:
			向下列代码，在第一遍扫描过程中便会被替换：
			TrueJump 100000 (1)
			替换为:
			UncondJump (1)
		
		3、对三元式数据进行简单分析，为之后的数据流分析、目标代码生成做准备
		筛选出函数中所有可能被定值的全局变量，为活跃变量分析中为了保证正确性而对全局变量所做的特殊处理准备。
		
		4、建立全局变量、局部变量、被引用的临时变量的统一编码，并建立了编码和变量信息之间的双射
		对所有三元式编号进行筛选，筛选出被引用的三元式编号做为临时变量与局部变量和全局变量一同进行编码，并建立变量信息与编码之间的双射。这样一方面方便了之后工作中对变量信息的随机查找，另一方面连续的编号也方便寄存器分配时图染色法的实现。
		使用的数据结构:
		包含所有变量和三元式信息结构体指针的数组，以及一个中间数组map_bridge，其中中间数组用来建立连续的编号与不连续的临时变量号和局部及全局变量之间的双射。这样虽然需要建立的连续数组的大小是随代码量增加而增加的，但由于本身每一个三元式都要保存在内存中，所以针对每一个三元式建立一个表项是与在三元式中增加一个域相同的，而且这个数组是临时的，在每处理完一个函数后就会被释放掉，所以空尽开销很小。由于是两个数组之间建立的双射，在查找变量信息时可以在常数时间内查到，在一定程度上提高了编译器本身的运行效率。
			而且由于整个数据结构都是static的，所以这两个数组对外部文件是不可见的，直接函数接口简洁的实现双射的功能，这样也减少了合作开发时因为诡异的数据结构而产生的协调问题。
		
	二、代码的第二遍深度优先扫描		
		1、递归划分基本块，并同时把基本块排列为最有利于数据流分析的深度优先顺序
		通过阅读资料，我们了解到，以深度优先的顺序遍历基本块来进行数据流分析，所需的迭代次数是最少的。所以我们便在生成代码的过程中直接把代码看作一个有向图来进行深度优先搜索，在搜索的过程中一方面划分基本块，一方面把基本块以DFS顺序放入数组中，并把尽本块的最后一条语句的跳转地址改为基本块编号，以方便流图到数序代码的还原以及基本块内指令的调度。
		在深度优先搜索的过程中，如果发现无条件跳转作为一个基本快的开始语句，则不生成新的基本块，而是继续搜索，并交搜索函数的返回基本块返回，这样便删除了多余的无条件跳转。
		在此过程中专门对三地值代码产生过程中产生的一些冗余的代码进行了重点优化：
			例如:
			像下列这种代码，由于中间代码产生中不便于调整，所以在基本块划分过程中便对这一类代码进行了重点优化
			if(a < c)
			   {
				  ;
			   }

			result:
			   (0)a < c
			   (1)TrueJump (0) (3)
			   (2)UncondJump (3)
			   (3)
	
		在基本块划分过程中，会通过判断条件跳转的两个后继节点是否是相同基本块来进行优化，因为不确定(3)号语句是否还是其它跳转的目标与句，所以无法直接删除跳转，但是可以直接把(1)(2)两条指令合为一条无条件跳转，这样一方面节省了一次条件判断，另一方面该无条件跳转可能会成为唯一能够跳转至后继基本块的跳转，则这种情况下，在尽本块恢复为顺序代码的过程中便会对该类无条件跳转进行删除。
	
	三、基本块的数据结构
	struct basic_block
	{
		int index;
		struct triargexpr_list * head;
		struct triargexpr_list * tail;
		struct basic_block_list * prev;
		struct basic_block_list * next;
	};
	其中index表明基本块的编号，所有基本块是利用深度优先的遍历顺序进行编号的。head和tail分别指出对应组织三地值代码顺序的链表的头尾。prev用俩记录该基本块的所有前驱基本块，而next用来记录所有后继基本块，其中basic_block_list是一个basic_block结构体指针的链表。

	三、流图的扫描
		1、从基本块恢复为顺序代码，并对代码进行重排序
		对流图进行深度优先搜索，并把基本块还原为重排后的三地址代码存入原来保存三地值代码的结构中。在此过程中，如果发现无条件跳转到的目的地，是该基本块的惟一后继，则对两个基本块进行合并，并删除多余的无条件跳转，这样如果后继基本块是另一基本块的直接后继，则该基本块最后会多产生一条无条件跳转语句，整个程序的无条件跳转数目不变。但是如果该无条件跳转是唯一能够跳到后继基本块的跳转，则此步骤优化了一步无条件跳转。

	四、关于递归开销的分析
		虽然利用递归深搜的方式遍历代码生成基本块和流图有种种好处，但是递归开销就与程序中的跳转数目相关，当代码量较大时这确实也是我们不得不考虑的。但是基于我们的所有优化都是针对每一个函数的，也就是说我们遍历的代码是一个函数的所有代码，一般情况下每一个函数的代码不宜过长，所以递归开销应该不会太大，当然如果某一个函数有几万个跳转，而且存在一个极深的路径，那我们的编译器可能确实会对栈产生不小的负担。
	
	基本块部分总结
		整个基本块划分过程，一方面充分利用两边扫描，第三元式尽可能地进行了数据分析；一方面又尽可能地对三元式进行了初步的化简，并删除了不可达代码，无用跳转等；另一方面还为数据流分析做好数据准备。







指针分析
	1、优化目的
	由于在机器码生成阶段，对指针所指内存的赋值和引用都可能引起寄存器中数据与内存中数据的不一致，所以需要在对指针所指内存操作前需要通过对所有全局变量和局部变量的load、store来保证寄存器与内存的数据一致性。
	于是我们决定使用数据流分析的方法来进行优化，通过数据流分析来确定在数组的每一个引用点上该数组可能指向的变量，从而缩小需要保证寄存器内存一致性的变量的范围，从而减少内存别名操作的开销。

	数据流方程
	OUT[B] = transb(IN[B])
	IN[B] = U OUT[P]

	其中的
	transb(S) = transk(transk-1(...trans2(trans1(S))))

	trans的规则如下
	1)a为数组元素
		s语句是p=&a或p=&a+-c
		trans(S)

	3、设计实现
	对*、[]、Arglist进行了分析
	
	4、效果评测



目标代码生成
	生成代码
	



窥孔优化
	一、优化目的
	由于人力有限，许多数据流分析阶段的优化不易完成，所以在数据流分析阶段只重点进行了活跃变量分析和指针分析，而其它冗余则需要在目标代码生成阶段尽可能消除，在目标代码生成后也要进行一些特定的冗余消除。同时因为本小组设计实现的sim模拟器的load指令的下一条指令如果出现数据相关，则不得不阻塞流水线一拍来等待mem阶段完成，所以在窥孔优化阶段进行一定的指令调度，尽可能地减少这种数据相关也非常必要。

	二、窥孔优化的实现
	1、指令调度
	在目标代码生成后，按序对目标代码进行扫描，如果load语句与紧跟的一条语句存在数据相关，则把这两条这令看作一个整体，生成两个集合：定值寄存器集和引用寄存器集；之后向上看一条代码，如果该条代码的有可能修改的寄存器在引用寄存器集中或该条代码所需引用的寄存器在定植寄存器集中，则该条指令无法调度，把该条指令有可能修改的寄存器加入定值寄存器集，把可能引用的寄存器加入引用寄存器集中，继续看上一条代码。
	一旦发现与整个定植寄存器集和引用寄存器集不相关的指令便可以调度。
	其中如果遇到跳转指令或标号，说明基本块已到上界，停止调度；如果遇到stw指令，因为在目标代码阶段无法确定改指令修改的是否是load引用的内存，所以无法确定是否有数据相关，所以直接默认存在数据相关，把改制令纳入定植寄存器集及引用寄存器集中，继续看上一条指令。
	可以通过设定指令窗口大小，来设置最大向上看的步数，不过一般基本块都不会太大。
	memset(des_reg_mark, 0, 32 * sizeof(char));
	memset(src_reg_mark, 0, 32 * sizeof(char));
	
	
	2、赋值操作与对应产生右值的操作的合并
	由于在中间代码生成阶段使用的是三元式，所以在充分利用三寄存器操作的指令上出现了一些困难，例如一个赋值操作：
	a = b + c
	需要两条三元式
	(1) + b c
	(2) = a (1)
	而这显然在生成代码时是浪费的，但是在目标代码生成阶段直接生成一条代码有一定的麻烦，所以我们在中间代码分析阶段对对应的指令进行了标记，并在生成的有可能优化的目标代码中加入了optimize标记，所以在窥孔阶段，一旦发现该条指令是可有化的(optimize == 1)，则看下一条指令是否是mov指令，如果是则对两条指令进行合并。



