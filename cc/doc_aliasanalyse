三地值代码生成
	1、表达式以下部分利用语法数处理
	2、表达式以上部分在文法中通过拉链回填处理，并在回填过程中对内容为空的条件跳转和循环进行优化
		举例分析

基本块划分及流图化简
	编译器在基本块划分过程中进行了两遍扫描，在这两遍扫描中不仅完成了基本块的划分，还充分利用两遍扫描尽可能地进行了数据处理和代码优化。同时在这一过程中，不仅要进行基本块划分，还要为最后基本块向代码的还原做好准备。下面便对两遍扫描以及之后的流图扫描所实现的功能进行简单的介绍。

	一、代码的第一遍扫描
		1、标记函数中所有可能的入口语句，为第二编扫描中的基本块划分做准备
		2、优化绝对发生的条件跳转为无条件跳转，为第二遍扫描中不可达代码和无用跳转的删除做准备。
			在第一遍扫描中会将所有条件恒为真的TrueJump和条件恒为假的FalseJump改为UncondJump，而将所有条件恒为假的TrueJump和条件恒为真的FalseJump改为Nullop，这样可以防止这样的代码打断基本块，而Nullop在最终生成目标代码时是不产生指令的。
			例如:
			向下列代码，在第一遍扫描过程中便会被替换：
			TrueJump 100000 (1)
			替换为:
			UncondJump (1)
		
		3、对三元式数据进行简单分析，为之后的数据流分析、目标代码生成做准备
		筛选出函数中所有可能被定值的全局变量，为活跃变量分析中为了保证正确性而对全局变量所做的特殊处理准备。
		
		4、建立全局变量、局部变量、被引用的临时变量的统一编码，并建立了编码和变量信息之间的双射
		对所有三元式编号进行筛选，筛选出被引用的三元式编号做为临时变量与局部变量和全局变量一同进行编码，并建立变量信息与编码之间的双射。这样一方面方便了之后工作中对变量信息的随机查找，另一方面连续的编号也方便寄存器分配时图染色法的实现。
		使用的数据结构:
		包含所有变量和三元式信息结构体指针的数组，以及一个中间数组map_bridge，其中中间数组用来建立连续的编号与不连续的临时变量号和局部及全局变量之间的双射。这样虽然需要建立的连续数组的大小是随代码量增加而增加的，但由于本身每一个三元式都要保存在内存中，所以针对每一个三元式建立一个表项是与在三元式中增加一个域相同的，而且这个数组是临时的，在每处理完一个函数后就会被释放掉，所以空尽开销很小。由于是两个数组之间建立的双射，在查找变量信息时可以在常数时间内查到，在一定程度上提高了编译器本身的运行效率。
			而且由于整个数据结构都是static的，所以这两个数组对外部文件是不可见的，直接函数接口简洁的实现双射的功能，这样也减少了合作开发时因为诡异的数据结构而产生的协调问题。
		
	二、代码的第二遍扫描		
		1、递归划分基本块，并同时把基本块排列为最有利于数据流分析的深度优先顺序
		通过阅读资料，我们了解到，以深度优先的顺序遍历基本块来进行数据流分析，所需的迭代次数是最少的。所以我们便在生成代码的过程中直接把代码看作一个有向图来进行深度优先搜索，在搜索的过程中一方面划分基本块，一方面把基本块以DFS顺序放入数组中，并把尽本块的最后一条语句的跳转地址改为基本块编号，以方便流图到数序代码的还原以及基本块内指令的调度。
		在深度优先搜索的过程中，如果发现无条件跳转作为一个基本快的开始语句，则不生成新的基本块，而是继续搜索，并交搜索函数的返回基本块返回，这样便删除了多余的无条件跳转。
		在此过程中专门对三地值代码产生过程中产生的一些冗余的代码进行了重点优化：
			例如:
			像下列这种代码，由于中间代码产生中不便于调整，所以在基本块划分过程中便对这一类代码进行了重点优化
			if(a < c)
			   {
				  ;
			   }

			result:
			   (0)a < c
			   (1)TrueJump (0) (3)
			   (2)UncondJump (3)
			   (3)
			在基本块划分过程中，会通过判断条件跳转的两个后继节点是否是相同基本块来进行优化，因为不确定(3)号语句是否还是其它跳转的目标与句，所以无法直接删除跳转，但是可以直接把(1)(2)两条指令合为一条无条件跳转，这样一方面节省了一次条件判断，另一方面该无条件跳转可能会成为唯一能够跳转至后继基本块的跳转，则这种情况下，在尽本块恢复为顺序代码的过程中便会对该类无条件跳转进行删除。

	三、流图的扫描
		1、从基本块恢复为顺序代码，并对代码进行重排序
		对流图进行深度优先搜索，并把基本块还原为重排后的三地址代码存入原来保存三地值代码的结构中。在此过程中，如果发现无条件跳转到的目的地，是该基本块的惟一后继，则对两个基本块进行合并，并删除多余的无条件跳转，这样如果后继基本块是另一基本块的直接后继，则该基本块最后会多产生一条无条件跳转语句，整个程序的无条件跳转数目不变。但是如果该无条件跳转是唯一能够跳到后继基本块的跳转，则此步骤优化了一步无条件跳转。
	
	基本块部分总结
		整个基本块划分过程，一方面充分利用两边扫描，第三元式尽可能地进行了数据分析；一方面又尽可能地对三元式进行了初步的化简，并删除了不可达代码，无用跳转等；另一方面还为数据流分析做好数据准备。







指针分析
	1、优化目的
	由于在机器码生成阶段，对指针所指内存的赋值和引用都可能引起寄存器中数据与内存中数据的不一致，所以需要在对指针所指内存操作前需要通过对所有全局变量和局部变量的load、store来保证寄存器与内存的数据一致性。
	于是我们决定使用数据流分析的方法来进行优化，通过数据流分析来确定在数组的每一个引用点上该数组可能指向的变量，从而缩小需要保证寄存器内存一致性的变量的范围，从而减少内存别名操作的开销。

	2、算法设计
	利用数据流分析的方法，通过不断迭代，解数据方程最终得出分析结果。
	其中指针分析的迭代方程：

	3、设计实现
	对*、[]、Arglist进行了分析
	
	4、效果评测



目标代码生成
	生成代码
	



窥孔优化
	一、优化目的
	由于人力有限，许多数据流分析阶段的优化不易完成，所以在数据流分析阶段只重点进行了活跃变量分析和指针分析，而其它冗余则需要在目标代码生成阶段尽可能消除，在目标代码生成后也要进行一些特定的冗余消除。同时因为本小组设计实现的sim模拟器的load指令的下一条指令如果出现数据相关，则不得不阻塞流水线一拍来等待mem阶段完成，所以在窥孔优化阶段进行一定的指令调度，尽可能地减少这种数据相关也非常必要。

	二、窥孔优化的实现
	1、指令调度
	在目标代码生成后，按序对目标代码进行扫描，如果load语句与紧跟的一条语句存在数据相关，则把这两条这令看作一个整体，生成两个集合：定值寄存器集和引用寄存器集；之后向上看一条代码，如果该条代码的有可能修改的寄存器在引用寄存器集中或该条代码所需引用的寄存器在定植寄存器集中，则该条指令无法调度，把该条指令有可能修改的寄存器加入定值寄存器集，把可能引用的寄存器加入引用寄存器集中，继续看上一条代码。
	一旦发现与整个定植寄存器集和引用寄存器集不相关的指令便可以调度。
	其中如果遇到跳转指令或标号，说明基本块已到上界，停止调度；如果遇到stw指令，因为在目标代码阶段无法确定改指令修改的是否是load引用的内存，所以无法确定是否有数据相关，所以直接默认存在数据相关，把改制令纳入定植寄存器集及引用寄存器集中，继续看上一条指令。
	可以通过设定指令窗口大小，来设置最大向上看的步数，不过一般基本块都不会太大。
	在
	赋值操作与对应产生右值的操作的合并


